# Implementation Guide: Building Features on Pai Ho's Baseline

## Overview

This document provides detailed, step-by-step instructions for implementing each feature from wkpup automation as a WRAPPER around Pai Ho's validated simulation core.

**Golden Rule**: NEVER modify Pai Ho's original files. All features are implemented as external layers.

---

## Prerequisites

### Step 0: Protect Pai Ho's Original Files

```bash
# Make Pai Ho's core files read-only
cd /nfs/site/disks/km6_io_37/users/chinseba/simulation/wkpup2/
find gpio/1p1v/dependencies/scripts/simulation_script/auto_pvt/ver03/ -type f -exec chmod 444 {} \;

# Verify
ls -l gpio/1p1v/dependencies/scripts/simulation_script/auto_pvt/ver03/sim_pvt.sh
# Should show: -r--r--r--
```

**Purpose**: Prevent accidental modification during development

---

## Feature 1: Web Interface Layer

### Architecture

```
┌──────────────┐
│   Browser    │
└──────┬───────┘
       │ HTTP POST /submit
       ▼
┌──────────────────────┐
│  Tornado Web Server  │
│  (main_tornado.py)   │
└──────┬───────────────┘
       │ subprocess.run()
       ▼
┌──────────────────────────────────┐
│  Pai Ho's sim_pvt.sh (ORIGINAL)  │
└──────────────────────────────────┘
```

### Step 1.1: Create Project Structure

```bash
cd /nfs/site/disks/km6_io_37/users/chinseba/simulation/wkpup2/

mkdir -p web_automation/{templates,static,modules}
cd web_automation/
```

### Step 1.2: Implement Configuration Generator

**File**: `web_automation/modules/config_generator.py`

```python
"""
Generate config.cfg in Pai Ho's exact format.
NEVER deviate from Pai Ho's parameter definitions.
"""

import os
from typing import Dict, List

# Pai Ho's EXACT parameter list (from COMPREHENSIVE_ANALYSIS.md)
PAIHO_CONFIG_TEMPLATE = """# Generated config.cfg (Pai Ho's format)
# Generated by web automation wrapper

mode={mode}
vccn={vccn}
vcctx={vcctx}
1st_supply_swp={supply_1st}
2nd_supply_swp={supply_2nd}
3rd_supply_swp={supply_3rd}
condition={condition}
CPU={cpu}
MEM={mem}
alter_extraction={alter_extraction}
alter_string1={alter_string1}
alter_string2={alter_string2}
sim_mode={sim_mode}
gs_corner={gs_corner}
gf_corner={gf_corner}
vcc_vid={vcc_vid}
simulator={simulator}
postlay_cross_cornerlist={postlay_cross_cornerlist}
"""

class PaiHoConfigGenerator:
    """Generate config.cfg compatible with Pai Ho's sim_pvt.sh"""
    
    # Whitelist: ONLY values validated by Pai Ho
    VALID_MODES = ['prelay', 'postlay']
    VALID_SIM_MODES = ['ac', 'dc']
    VALID_CONDITIONS = ['perf', 'func', 'htol']
    VALID_SIMULATORS = ['primesim', 'finesim']
    
    def __init__(self, paiho_csv_dir: str):
        """
        Args:
            paiho_csv_dir: Path to Pai Ho's configuration/*.csv files
                          (e.g., .../ver03/configuration/)
        """
        self.csv_dir = paiho_csv_dir
        self.valid_corners = self._load_valid_corners()
        self.valid_voltages = self._load_valid_voltages()
        
    def _load_valid_corners(self) -> List[str]:
        """Load corner whitelist from Pai Ho's table_corner_list.csv"""
        csv_file = os.path.join(self.csv_dir, 'table_corner_list.csv')
        
        corners = []
        with open(csv_file, 'r') as f:
            for line in f:
                if line.strip() and not line.startswith('#'):
                    # Parse Pai Ho's CSV format
                    parts = line.strip().split(',')
                    corners.append(parts[0])  # First column is corner name
        
        return corners
    
    def _load_valid_voltages(self) -> Dict[str, List[str]]:
        """Load voltage whitelist from Pai Ho's table_supply_list*.csv"""
        voltages = {'ac': [], 'dc': []}
        
        for sim_mode in ['ac', 'dc']:
            csv_file = os.path.join(self.csv_dir, f'table_supply_list_{sim_mode}.csv')
            
            with open(csv_file, 'r') as f:
                for line in f:
                    if line.strip() and not line.startswith('#'):
                        parts = line.strip().split(',')
                        voltages[sim_mode].append(parts[0])
        
        return voltages
    
    def validate_parameters(self, params: Dict) -> None:
        """
        Validate ALL parameters against Pai Ho's whitelists.
        Raises ValueError if any parameter is invalid.
        """
        # Validate mode
        if params['mode'] not in self.VALID_MODES:
            raise ValueError(f"Invalid mode: {params['mode']}. "
                           f"Valid: {self.VALID_MODES}")
        
        # Validate sim_mode
        if params['sim_mode'] not in self.VALID_SIM_MODES:
            raise ValueError(f"Invalid sim_mode: {params['sim_mode']}. "
                           f"Valid: {self.VALID_SIM_MODES}")
        
        # Validate corners (if specified)
        if 'corners' in params:
            requested_corners = params['corners'].split(',')
            for corner in requested_corners:
                if corner not in self.valid_corners:
                    raise ValueError(f"Invalid corner: {corner}. "
                                   f"Valid: {self.valid_corners}")
        
        # Validate voltages
        sim_mode = params['sim_mode']
        if 'voltages' in params:
            requested_voltages = params['voltages'].split(',')
            for voltage in requested_voltages:
                if voltage not in self.valid_voltages[sim_mode]:
                    raise ValueError(f"Invalid voltage: {voltage} for {sim_mode}. "
                                   f"Valid: {self.valid_voltages[sim_mode]}")
    
    def generate(self, user_params: Dict) -> str:
        """
        Generate config.cfg from user parameters.
        
        Args:
            user_params: Dictionary of user-provided parameters
            
        Returns:
            Path to generated config.cfg file
            
        Raises:
            ValueError: If any parameter violates Pai Ho's whitelist
        """
        # Validate FIRST
        self.validate_parameters(user_params)
        
        # Apply defaults (Pai Ho's defaults from COMPREHENSIVE_ANALYSIS.md)
        config = {
            'mode': user_params.get('mode', 'prelay'),
            'vccn': user_params.get('vccn', '1p1v'),
            'vcctx': user_params.get('vcctx', '1p1v'),
            'supply_1st': user_params.get('supply_1st', 'all'),
            'supply_2nd': user_params.get('supply_2nd', 'all'),
            'supply_3rd': user_params.get('supply_3rd', 'all'),
            'condition': user_params.get('condition', 'perf'),
            'cpu': user_params.get('cpu', '8'),
            'mem': user_params.get('mem', '16'),
            'alter_extraction': user_params.get('alter_extraction', 'typical'),
            'alter_string1': user_params.get('alter_string1', ''),
            'alter_string2': user_params.get('alter_string2', ''),
            'sim_mode': user_params.get('sim_mode', 'ac'),
            'gs_corner': user_params.get('gs_corner', 'NA'),
            'gf_corner': user_params.get('gf_corner', 'NA'),
            'vcc_vid': user_params.get('vcc_vid', 'no'),
            'simulator': user_params.get('simulator', 'primesim'),
            'postlay_cross_cornerlist': user_params.get('postlay_cross_cornerlist', ''),
        }
        
        # Generate config.cfg using Pai Ho's template
        config_content = PAIHO_CONFIG_TEMPLATE.format(**config)
        
        # Write to temporary file (Pai Ho's sim_pvt.sh will read this)
        config_file = '/tmp/generated_config.cfg'
        with open(config_file, 'w') as f:
            f.write(config_content)
        
        return config_file


# Usage example
if __name__ == '__main__':
    # Initialize with Pai Ho's CSV directory
    generator = PaiHoConfigGenerator(
        paiho_csv_dir='/nfs/site/disks/km6_io_22/users/paihobon/simulation/simulation_script/auto_pvt/ver03/configuration/'
    )
    
    # User submits parameters via web form
    user_params = {
        'mode': 'prelay',
        'sim_mode': 'ac',
        'vccn': '1p1v',
        'condition': 'perf',
    }
    
    # Validate and generate
    try:
        config_file = generator.generate(user_params)
        print(f"Generated: {config_file}")
    except ValueError as e:
        print(f"ERROR: {e}")
```

### Step 1.3: Implement Simulation Executor

**File**: `web_automation/modules/paiho_executor.py`

```python
"""
Execute Pai Ho's sim_pvt.sh via subprocess.
NEVER modify sim_pvt.sh's behavior.
"""

import subprocess
import os
import shutil
from typing import Dict, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class SimulationResult:
    """Result of Pai Ho's simulation"""
    job_id: str
    status: str  # 'success', 'failed', 'running'
    stdout: str
    stderr: str
    start_time: datetime
    end_time: Optional[datetime]
    result_dir: Optional[str]


class PaiHoExecutor:
    """Execute Pai Ho's simulation scripts WITHOUT modification"""
    
    def __init__(self, paiho_workdir: str, paiho_script_dir: str):
        """
        Args:
            paiho_workdir: Working directory (e.g., gpio/1p1v/)
            paiho_script_dir: Path to Pai Ho's ver03 scripts
        """
        self.workdir = paiho_workdir
        self.script_dir = paiho_script_dir
        
        # Pai Ho's ORIGINAL sim_pvt.sh
        self.sim_pvt_script = os.path.join(script_dir, 'sim_pvt.sh')
        
        # Verify Pai Ho's script exists and is ver03
        self._verify_paiho_script()
    
    def _verify_paiho_script(self):
        """Ensure we're using Pai Ho's ORIGINAL ver03 script"""
        if not os.path.exists(self.sim_pvt_script):
            raise FileNotFoundError(f"Pai Ho's sim_pvt.sh not found: {self.sim_pvt_script}")
        
        # Check script has expected size (589 lines for ver03)
        with open(self.sim_pvt_script, 'r') as f:
            lines = f.readlines()
        
        if len(lines) != 589:
            raise ValueError(f"WARNING: sim_pvt.sh has {len(lines)} lines, "
                           f"expected 589 (ver03). May be wrong version!")
        
        # Verify it's read-only (protection against modification)
        stat = os.stat(self.sim_pvt_script)
        if stat.st_mode & 0o200:  # Write permission exists
            print(f"WARNING: {self.sim_pvt_script} is writable! "
                  f"Consider making read-only: chmod 444")
    
    def execute_stage(self, config_file: str, stage: str) -> SimulationResult:
        """
        Execute ONE stage of Pai Ho's simulation.
        
        Args:
            config_file: Path to config.cfg (Pai Ho's format)
            stage: 'gen', 'run', 'ext', 'srt', 'bkp', or 'usr'
            
        Returns:
            SimulationResult with execution details
        """
        # Validate stage
        valid_stages = ['gen', 'run', 'ext', 'srt', 'bkp', 'usr']
        if stage not in valid_stages:
            raise ValueError(f"Invalid stage: {stage}. Valid: {valid_stages}")
        
        # Copy config.cfg to Pai Ho's working directory
        dest_config = os.path.join(self.workdir, 'config.cfg')
        shutil.copy(config_file, dest_config)
        
        # Execute Pai Ho's ORIGINAL sim_pvt.sh
        job_id = f"web_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        start_time = datetime.now()
        
        cmd = [
            'bash',
            self.sim_pvt_script,
            dest_config,
            stage  # gen, run, ext, srt, bkp, or usr
        ]
        
        print(f"Executing Pai Ho's sim_pvt.sh: {' '.join(cmd)}")
        
        result = subprocess.run(
            cmd,
            cwd=self.workdir,  # Run in Pai Ho's working directory
            capture_output=True,
            text=True,
            env=os.environ.copy()  # Pass through environment
        )
        
        end_time = datetime.now()
        
        # Determine result directory (Pai Ho's output location)
        result_dir = None
        if result.returncode == 0:
            # Pai Ho creates results in specific locations
            if stage == 'bkp':
                # Look for latest 00bkp_* directory
                bkp_dirs = [d for d in os.listdir(self.workdir) 
                           if d.startswith('00bkp_')]
                if bkp_dirs:
                    result_dir = os.path.join(self.workdir, sorted(bkp_dirs)[-1])
        
        return SimulationResult(
            job_id=job_id,
            status='success' if result.returncode == 0 else 'failed',
            stdout=result.stdout,
            stderr=result.stderr,
            start_time=start_time,
            end_time=end_time,
            result_dir=result_dir
        )
    
    def execute_full_workflow(self, config_file: str) -> SimulationResult:
        """
        Execute complete Pai Ho's workflow: gen → run → ext → srt → bkp
        
        This is the SAFEST method - follows Pai Ho's exact sequence.
        """
        stages = ['gen', 'run', 'ext', 'srt', 'bkp']
        
        overall_start = datetime.now()
        job_id = f"web_{overall_start.strftime('%Y%m%d_%H%M%S')}"
        
        for stage in stages:
            print(f"Executing stage: {stage}")
            result = self.execute_stage(config_file, stage)
            
            if result.status != 'success':
                # Stop on first failure (Pai Ho's behavior)
                return SimulationResult(
                    job_id=job_id,
                    status='failed',
                    stdout=result.stdout,
                    stderr=result.stderr,
                    start_time=overall_start,
                    end_time=datetime.now(),
                    result_dir=None
                )
        
        return SimulationResult(
            job_id=job_id,
            status='success',
            stdout=result.stdout,
            stderr=result.stderr,
            start_time=overall_start,
            end_time=datetime.now(),
            result_dir=result.result_dir
        )


# Usage example
if __name__ == '__main__':
    executor = PaiHoExecutor(
        paiho_workdir='/nfs/site/disks/km6_io_37/users/chinseba/simulation/wkpup2/gpio/1p1v',
        paiho_script_dir='/nfs/site/disks/km6_io_22/users/paihobon/simulation/simulation_script/auto_pvt/ver03'
    )
    
    # Execute full workflow
    result = executor.execute_full_workflow('/tmp/generated_config.cfg')
    
    if result.status == 'success':
        print(f"SUCCESS: Results in {result.result_dir}")
    else:
        print(f"FAILED: {result.stderr}")
```

### Step 1.4: Implement Web Server

**File**: `web_automation/main_tornado.py`

```python
"""
Tornado web server - wrapper around Pai Ho's simulation core.
Provides user-friendly interface while maintaining Pai Ho's accuracy.
"""

import tornado.ioloop
import tornado.web
import tornado.websocket
import json
import os
from modules.config_generator import PaiHoConfigGenerator
from modules.paiho_executor import PaiHoExecutor

# Paths to Pai Ho's ORIGINAL files
PAIHO_CSV_DIR = '/nfs/site/disks/km6_io_22/users/paihobon/simulation/simulation_script/auto_pvt/ver03/configuration'
PAIHO_SCRIPT_DIR = '/nfs/site/disks/km6_io_22/users/paihobon/simulation/simulation_script/auto_pvt/ver03'
PAIHO_WORKDIR = '/nfs/site/disks/km6_io_37/users/chinseba/simulation/wkpup2/gpio/1p1v'


class IndexHandler(tornado.web.RequestHandler):
    """Main page - job submission form"""
    
    def get(self):
        self.render('templates/index.html')


class SubmitHandler(tornado.web.RequestHandler):
    """Handle job submission"""
    
    def post(self):
        try:
            # Extract user parameters from form
            user_params = {
                'mode': self.get_argument('mode'),
                'sim_mode': self.get_argument('sim_mode'),
                'vccn': self.get_argument('vccn'),
                'condition': self.get_argument('condition'),
                'cpu': self.get_argument('cpu', '8'),
                'mem': self.get_argument('mem', '16'),
                'simulator': self.get_argument('simulator', 'primesim'),
            }
            
            # Generate config.cfg (Pai Ho's format, with validation)
            generator = PaiHoConfigGenerator(PAIHO_CSV_DIR)
            config_file = generator.generate(user_params)
            
            # Execute Pai Ho's ORIGINAL simulation
            executor = PaiHoExecutor(PAIHO_WORKDIR, PAIHO_SCRIPT_DIR)
            result = executor.execute_full_workflow(config_file)
            
            # Return results to user
            if result.status == 'success':
                self.write({
                    'status': 'success',
                    'job_id': result.job_id,
                    'result_dir': result.result_dir,
                    'message': 'Simulation completed successfully'
                })
            else:
                self.write({
                    'status': 'error',
                    'message': f'Simulation failed: {result.stderr}'
                })
                
        except ValueError as e:
            # Parameter validation failed
            self.write({
                'status': 'error',
                'message': f'Invalid parameters: {str(e)}'
            })
        except Exception as e:
            # Other errors
            self.write({
                'status': 'error',
                'message': f'Execution error: {str(e)}'
            })


class ProgressMonitor(tornado.websocket.WebSocketHandler):
    """WebSocket for real-time progress monitoring"""
    
    def open(self):
        print("WebSocket opened")
    
    def on_message(self, message):
        # Client requests progress for job_id
        data = json.loads(message)
        job_id = data['job_id']
        
        # Tail Pai Ho's log file (READ-ONLY)
        log_file = os.path.join(PAIHO_WORKDIR, 'log', 'simulation.log')
        
        # Send progress updates (simplified - full implementation would tail file)
        self.write_message({
            'job_id': job_id,
            'progress': 50,
            'message': 'Simulation in progress...'
        })
    
    def on_close(self):
        print("WebSocket closed")


def make_app():
    return tornado.web.Application([
        (r"/", IndexHandler),
        (r"/submit", SubmitHandler),
        (r"/progress", ProgressMonitor),
    ],
    template_path=os.path.join(os.path.dirname(__file__), "templates"),
    static_path=os.path.join(os.path.dirname(__file__), "static"),
    debug=True
    )


if __name__ == "__main__":
    app = make_app()
    app.listen(8888)
    print("Web automation server started on http://localhost:8888")
    print(f"Using Pai Ho's scripts from: {PAIHO_SCRIPT_DIR}")
    print(f"Working directory: {PAIHO_WORKDIR}")
    tornado.ioloop.IOLoop.current().start()
```

### Step 1.5: Create Web UI Template

**File**: `web_automation/templates/index.html`

```html
<!DOCTYPE html>
<html>
<head>
    <title>WKPUP Automation - Powered by Pai Ho's Validated Core</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .form-group { margin-bottom: 15px; }
        label { display: inline-block; width: 200px; font-weight: bold; }
        select, input { padding: 5px; width: 300px; }
        button { background: #4CAF50; color: white; padding: 10px 20px; 
                 border: none; cursor: pointer; font-size: 16px; }
        button:hover { background: #45a049; }
        .info { background: #e7f3fe; padding: 15px; margin-bottom: 20px; 
                border-left: 6px solid #2196F3; }
        #result { margin-top: 20px; padding: 15px; display: none; }
        .success { background: #d4edda; border-left: 6px solid #28a745; }
        .error { background: #f8d7da; border-left: 6px solid #dc3545; }
    </style>
</head>
<body>
    <h1>WKPUP Automation System</h1>
    <div class="info">
        <strong>Notice:</strong> This interface uses Pai Ho's scientifically validated 
        simulation core (ver03). All parameters are validated against Pai Ho's whitelists 
        to ensure 100% accuracy.
    </div>
    
    <form id="simulationForm">
        <div class="form-group">
            <label>Mode:</label>
            <select name="mode" required>
                <option value="prelay">Pre-Layout</option>
                <option value="postlay">Post-Layout</option>
            </select>
        </div>
        
        <div class="form-group">
            <label>Simulation Mode:</label>
            <select name="sim_mode" required>
                <option value="ac">AC</option>
                <option value="dc">DC</option>
            </select>
        </div>
        
        <div class="form-group">
            <label>Voltage Domain (vccn):</label>
            <select name="vccn" required>
                <option value="1p1v">1.1V</option>
                <option value="1p2v">1.2V</option>
                <option value="1p8v">1.8V</option>
            </select>
        </div>
        
        <div class="form-group">
            <label>Condition:</label>
            <select name="condition" required>
                <option value="perf">Performance</option>
                <option value="func">Functional</option>
                <option value="htol">HTOL</option>
            </select>
        </div>
        
        <div class="form-group">
            <label>CPU Cores:</label>
            <input type="number" name="cpu" value="8" min="1" max="32">
        </div>
        
        <div class="form-group">
            <label>Memory (GB):</label>
            <input type="number" name="mem" value="16" min="1" max="128">
        </div>
        
        <div class="form-group">
            <label>Simulator:</label>
            <select name="simulator">
                <option value="primesim">PrimeSim</option>
                <option value="finesim">FineSim</option>
            </select>
        </div>
        
        <button type="submit">Submit Simulation</button>
    </form>
    
    <div id="result"></div>
    
    <script>
        document.getElementById('simulationForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const formData = new FormData(e.target);
            const params = {};
            formData.forEach((value, key) => params[key] = value);
            
            // Submit to server
            const response = await fetch('/submit', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: new URLSearchParams(params)
            });
            
            const result = await response.json();
            const resultDiv = document.getElementById('result');
            
            if (result.status === 'success') {
                resultDiv.className = 'success';
                resultDiv.innerHTML = `
                    <strong>Success!</strong><br>
                    Job ID: ${result.job_id}<br>
                    Results: ${result.result_dir}
                `;
            } else {
                resultDiv.className = 'error';
                resultDiv.innerHTML = `
                    <strong>Error:</strong><br>
                    ${result.message}
                `;
            }
            
            resultDiv.style.display = 'block';
        });
    </script>
</body>
</html>
```

---

## Feature 2: Database Tracking Layer

### Step 2.1: Create Database Schema

**File**: `web_automation/modules/database.py`

```python
"""
Database tracking for Pai Ho's simulations.
Stores metadata and results WITHOUT modifying simulation logic.
"""

import sqlite3
from datetime import datetime
from typing import Dict, List, Optional
import os
import re


class SimulationDatabase:
    """Track Pai Ho's simulation jobs and results"""
    
    def __init__(self, db_path: str = 'simulation_tracking.db'):
        self.db_path = db_path
        self.conn = None
        self._initialize_schema()
    
    def _initialize_schema(self):
        """Create database schema"""
        self.conn = sqlite3.connect(self.db_path)
        cursor = self.conn.cursor()
        
        # Jobs table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS jobs (
                job_id TEXT PRIMARY KEY,
                submitted_at TIMESTAMP,
                user TEXT,
                mode TEXT,
                sim_mode TEXT,
                vccn TEXT,
                vcctx TEXT,
                condition TEXT,
                corners TEXT,
                temperatures TEXT,
                voltages TEXT,
                cpu INTEGER,
                mem INTEGER,
                simulator TEXT,
                status TEXT,
                config_file TEXT,
                result_dir TEXT,
                completed_at TIMESTAMP
            )
        """)
        
        # Results table (parsed from Pai Ho's creport.txt)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS results (
                result_id INTEGER PRIMARY KEY AUTOINCREMENT,
                job_id TEXT,
                corner TEXT,
                temperature TEXT,
                voltage TEXT,
                tphl REAL,
                tplh REAL,
                ipeak REAL,
                power REAL,
                pass_fail TEXT,
                raw_data TEXT,
                FOREIGN KEY (job_id) REFERENCES jobs(job_id)
            )
        """)
        
        self.conn.commit()
    
    def record_job_submission(self, job_id: str, params: Dict) -> None:
        """Record job submission (before execution)"""
        cursor = self.conn.cursor()
        
        cursor.execute("""
            INSERT INTO jobs (
                job_id, submitted_at, user, mode, sim_mode, vccn, vcctx,
                condition, cpu, mem, simulator, status, config_file
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            job_id,
            datetime.now(),
            os.getenv('USER', 'unknown'),
            params.get('mode'),
            params.get('sim_mode'),
            params.get('vccn'),
            params.get('vcctx', params.get('vccn')),  # Default vcctx=vccn
            params.get('condition'),
            params.get('cpu', 8),
            params.get('mem', 16),
            params.get('simulator', 'primesim'),
            'submitted',
            params.get('config_file')
        ))
        
        self.conn.commit()
    
    def update_job_completion(self, job_id: str, status: str, result_dir: Optional[str]) -> None:
        """Update job status after completion"""
        cursor = self.conn.cursor()
        
        cursor.execute("""
            UPDATE jobs 
            SET status = ?, result_dir = ?, completed_at = ?
            WHERE job_id = ?
        """, (status, result_dir, datetime.now(), job_id))
        
        self.conn.commit()
    
    def parse_paiho_results(self, result_dir: str) -> List[Dict]:
        """
        Parse Pai Ho's creport.txt and extract results.
        This is READ-ONLY - never modifies Pai Ho's files.
        """
        creport_file = os.path.join(result_dir, 'creport.txt')
        
        if not os.path.exists(creport_file):
            raise FileNotFoundError(f"Pai Ho's creport.txt not found: {creport_file}")
        
        results = []
        
        with open(creport_file, 'r') as f:
            for line in f:
                # Parse Pai Ho's report format
                # Example: "TT typical 85 v1nom tphl=1.23e-9 tplh=2.34e-9 ..."
                
                match = re.match(
                    r'(\w+)\s+(\w+)\s+([-\d]+)\s+(\w+)\s+tphl=([\d.e-]+)\s+tplh=([\d.e-]+)',
                    line.strip()
                )
                
                if match:
                    corner, extraction, temp, voltage, tphl, tplh = match.groups()
                    
                    results.append({
                        'corner': corner,
                        'temperature': temp,
                        'voltage': voltage,
                        'tphl': float(tphl),
                        'tplh': float(tplh),
                        'raw_data': line.strip()
                    })
        
        return results
    
    def store_results(self, job_id: str, result_dir: str) -> None:
        """Parse and store Pai Ho's results in database"""
        results = self.parse_paiho_results(result_dir)
        
        cursor = self.conn.cursor()
        
        for result in results:
            cursor.execute("""
                INSERT INTO results (
                    job_id, corner, temperature, voltage, tphl, tplh, raw_data
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (
                job_id,
                result['corner'],
                result['temperature'],
                result['voltage'],
                result['tphl'],
                result['tplh'],
                result['raw_data']
            ))
        
        self.conn.commit()
    
    def query_jobs(self, filters: Dict = None) -> List[Dict]:
        """Query jobs with optional filters"""
        cursor = self.conn.cursor()
        
        query = "SELECT * FROM jobs"
        params = []
        
        if filters:
            conditions = []
            for key, value in filters.items():
                conditions.append(f"{key} = ?")
                params.append(value)
            
            query += " WHERE " + " AND ".join(conditions)
        
        query += " ORDER BY submitted_at DESC"
        
        cursor.execute(query, params)
        
        columns = [desc[0] for desc in cursor.description]
        return [dict(zip(columns, row)) for row in cursor.fetchall()]


# Usage example
if __name__ == '__main__':
    db = SimulationDatabase()
    
    # Record job submission
    job_id = 'web_20250501_120000'
    db.record_job_submission(job_id, {
        'mode': 'prelay',
        'sim_mode': 'ac',
        'vccn': '1p1v',
        'condition': 'perf',
        'config_file': '/tmp/config.cfg'
    })
    
    # After simulation completes, store results
    result_dir = '/path/to/paiho/00bkp_202505011200'
    db.update_job_completion(job_id, 'success', result_dir)
    db.store_results(job_id, result_dir)
    
    # Query jobs
    recent_jobs = db.query_jobs({'status': 'success'})
    for job in recent_jobs:
        print(f"Job {job['job_id']}: {job['mode']} @ {job['vccn']}")
```

---

## Testing Strategy

### Test 1: Bit-Identical Output Test

**File**: `web_automation/tests/test_bit_identical.py`

```python
"""
Verify web interface produces IDENTICAL output to manual Pai Ho execution.
This is the MOST IMPORTANT test.
"""

import subprocess
import filecmp
import os
import shutil

def test_web_vs_manual_identical():
    """
    Submit identical job via:
    1. Web interface
    2. Manual Pai Ho method
    
    Verify ALL output files are bit-identical.
    """
    # Parameters
    params = {
        'mode': 'prelay',
        'sim_mode': 'ac',
        'vccn': '1p1v',
        'condition': 'perf',
    }
    
    # Method 1: Via web interface
    from modules.config_generator import PaiHoConfigGenerator
    from modules.paiho_executor import PaiHoExecutor
    
    generator = PaiHoConfigGenerator(PAIHO_CSV_DIR)
    config_file = generator.generate(params)
    
    executor = PaiHoExecutor(PAIHO_WORKDIR, PAIHO_SCRIPT_DIR)
    web_result = executor.execute_full_workflow(config_file)
    
    # Method 2: Direct manual execution
    manual_config = '/tmp/manual_config.cfg'
    # (manually create config.cfg)
    
    manual_result = subprocess.run([
        'bash',
        '/nfs/.../ver03/sim_pvt.sh',
        manual_config,
        'gen'
    ])
    
    # Compare ALL output files
    web_dir = web_result.result_dir
    manual_dir = '...'  # manual result directory
    
    comparison = filecmp.dircmp(web_dir, manual_dir)
    
    # Assert NO differences
    assert len(comparison.diff_files) == 0, f"Different files: {comparison.diff_files}"
    assert len(comparison.left_only) == 0, f"Web-only files: {comparison.left_only}"
    assert len(comparison.right_only) == 0, f"Manual-only files: {comparison.right_only}"
    
    print("✅ PASS: Web interface produces bit-identical output to manual execution")
```

---

## Deployment Checklist

### Pre-Deployment
- [ ] Pai Ho's original files are read-only (`chmod 444`)
- [ ] All unit tests pass
- [ ] Bit-identical test passes
- [ ] Parameter validation complete
- [ ] Database schema created

### Deployment
- [ ] Start web server: `python main_tornado.py`
- [ ] Access: http://localhost:8888
- [ ] Submit test job
- [ ] Verify results in database

### Post-Deployment
- [ ] Monitor logs for errors
- [ ] Verify NO modifications to Pai Ho's files
- [ ] Check database accuracy
- [ ] User acceptance testing

---

## Summary

**Implementation Approach**:
1. ✅ Pai Ho's core files are NEVER modified
2. ✅ All features are external wrappers
3. ✅ Parameter validation against Pai Ho's whitelists
4. ✅ Bit-identical output verification
5. ✅ Database tracks results without affecting simulation

**Next Steps**:
- Implement remaining features (multi-domain, monitoring)
- Complete test suite
- Performance optimization
- Documentation finalization

**Expected Outcome**: User-friendly web interface with Pai Ho's proven accuracy.
