"""
Simulation orchestration module
Handles simulation lifecycle: gen, run, extract, sort, backup
"""

import os
import subprocess
import shutil
from datetime import datetime
from typing import Dict, Optional, List
from pathlib import Path

# Import voltage domain manager
from voltage_domain_manager import (
    ensure_voltage_domain, 
    get_available_voltage_domains
)

# Valid PVT corner names
VALID_CORNERS = [
    'TT',       # Typical-Typical
    'FFG',      # Fast-Fast Global
    'SSG',      # Slow-Slow Global
    'FSG',      # Fast-Slow Global
    'SFG',      # Slow-Fast Global
    'FFAG',     # Fast-Fast Alternate Global
    'SSAG',     # Slow-Slow Alternate Global
    'FFG_SSG',  # Mixed corner
    'SSG_FFG',  # Mixed corner
]


def validate_custom_corners(corners: List[str]) -> Dict:
    """
    Validate custom corner selection.
    
    Args:
        corners: List of corner names (e.g., ['TT', 'FFG', 'SSG'])
        
    Returns:
        Dictionary with validation result:
        - valid: bool
        - error: str (if invalid)
        - warning: str (optional)
        - corners: List[str] (if valid)
    """
    if not corners or len(corners) == 0:
        return {'valid': False, 'error': 'No corners selected'}
    
    # Check for invalid corner names
    invalid = [c for c in corners if c not in VALID_CORNERS]
    if invalid:
        return {
            'valid': False, 
            'error': f'Invalid corner names: {", ".join(invalid)}. Valid corners: {", ".join(VALID_CORNERS)}'
        }
    
    # Check for duplicates
    if len(corners) != len(set(corners)):
        duplicates = [c for c in set(corners) if corners.count(c) > 1]
        return {'valid': False, 'error': f'Duplicate corners: {", ".join(duplicates)}'}
    
    # Warning if TT not selected (recommended baseline)
    warning = None
    if 'TT' not in corners:
        warning = 'TT (baseline) not selected - recommended to include for comparison'
    
    result = {'valid': True, 'corners': corners}
    if warning:
        result['warning'] = warning
    
    return result


def generate_sim_id() -> str:
    """Generate unique simulation ID"""
    return f"sim_{datetime.now().strftime('%Y%m%d_%H%M%S')}"


def create_work_directory(project: str, voltage_domain: str, sim_id: str) -> str:
    """
    Create working directory for simulation.
    Automatically creates voltage domain structure if it doesn't exist.
    
    Args:
        project: "i3c" or "gpio"
        voltage_domain: "1p1v", "1p8v", "0p9v", etc.
        sim_id: Unique simulation ID
        
    Returns:
        Path to working directory
        
    Raises:
        ValueError: If voltage domain is invalid or creation fails
    """
    # Ensure voltage domain exists (creates if needed)
    domain_info = ensure_voltage_domain(project, voltage_domain)
    
    if not domain_info['success']:
        error_msg = domain_info.get('error', 'Unknown error')
        raise ValueError(f"Voltage domain setup failed: {error_msg}")
    
    if domain_info.get('created'):
        print(f"üÜï Created new voltage domain: {voltage_domain} ({domain_info['voltage_value']}V)")
    
    # Use base_path from voltage domain manager
    base_path = domain_info['base_path']
    
    # Create runs directory if it doesn't exist
    runs_dir = os.path.join(base_path, "runs")
    os.makedirs(runs_dir, exist_ok=True)
    
    # Create simulation-specific directory
    work_dir = os.path.join(runs_dir, sim_id)
    os.makedirs(work_dir, exist_ok=True)
    
    print(f"üìÅ Created work directory: {work_dir}")
    return work_dir


def copy_simulation_files(work_dir: str, project: str, voltage_domain: str, custom_template_path: Optional[str] = None) -> bool:
    """
    Copy necessary files from project directory to work directory
    
    Args:
        work_dir: Working directory path
        project: "i3c" or "gpio"
        voltage_domain: "1p1v"
        custom_template_path: Optional custom path to template directory
        
    Returns:
        True if successful, False otherwise
    """
    source_dir = f"/nfs/site/disks/km6_io_37/users/chinseba/simulation/wkpup/{project}/{voltage_domain}"
    
    files_to_copy = [
        "config.cfg",
        "sim_pvt_local.sh",
        "local_pvt_loop.sh",     # CRITICAL: Our modified version with user-selected temperatures
        "local_extract.sh",
        "local_move.sh",
        "runme_local.sh"
    ]
    
    try:
        # Copy files
        for filename in files_to_copy:
            src = os.path.join(source_dir, filename)
            dst = os.path.join(work_dir, filename)
            if os.path.exists(src):
                shutil.copy2(src, dst)
                print(f"  ‚úì Copied {filename}")
            else:
                print(f"  ‚ö†Ô∏è File not found: {src}")
        
        # Copy template directory
        if custom_template_path and os.path.exists(custom_template_path):
            # Use custom template
            template_dst = os.path.join(work_dir, "template")
            shutil.copytree(custom_template_path, template_dst)
            print(f"  ‚úì Copied CUSTOM template/ from: {custom_template_path}")
        else:
            # Use default template
            template_src = os.path.join(source_dir, "template")
            if os.path.exists(template_src):
                template_dst = os.path.join(work_dir, "template")
                shutil.copytree(template_src, template_dst)
                print(f"  ‚úì Copied default template/ directory")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error copying files: {e}")
        return False


def update_config_file(work_dir: str, corners: List[str], temperatures: List[str], temp_voltages: Optional[dict] = None,
                      nb_cores: int = 2, nb_memory: int = 2) -> bool:
    """
    Update config.cfg with selected corners, temperatures, per-temp voltage specs, and NetBatch resources
    
    Args:
        work_dir: Working directory path
        corners: List of corner names (e.g., ['TT', 'FFG', 'SSG'])
        temperatures: List of temperatures (e.g., ['-40', '85', '100', '125'])
        temp_voltages: Dict of per-temp voltage specs (e.g., {'temp_-40_voltages': 'v1min_v2min,v1nom_v2nom', ...})
        nb_cores: Number of CPU cores for NetBatch (default: 2)
        nb_memory: Memory in GB for NetBatch (default: 2)
        
    Returns:
        True if successful
    """
    config_path = os.path.join(work_dir, "config.cfg")
    sim_pvt_path = os.path.join(work_dir, "sim_pvt_local.sh")
    
    if not os.path.exists(config_path):
        print(f"‚ùå config.cfg not found at {config_path}")
        return False
    
    # Read config
    with open(config_path, 'r') as f:
        lines = f.readlines()
    
    # Always use 'custom' condition for flexible voltage control
    condition_value = 'custom'
    
    # Supply sweep settings remain unchanged (controlled by project config)
    # We don't modify supply_swp settings - they're set per project
    
    # Remove old temp_list and any existing temp_XX_voltages lines
    lines = [line for line in lines if not line.startswith('temp_')]
    
    # Update condition, CPU #, MEM [G]
    updated_condition = False
    updated_cpu = False
    updated_mem = False
    
    for i, line in enumerate(lines):
        if line.startswith('condition:'):
            lines[i] = f"condition:{condition_value}\n"
            updated_condition = True
        elif line.startswith('CPU #:'):
            lines[i] = f"CPU #:{nb_cores}\n"
            updated_cpu = True
        elif line.startswith('MEM [G]:'):
            lines[i] = f"MEM [G]:{nb_memory}\n"
            updated_mem = True
    
    # Add temp_list
    temp_list_line = f"temp_list:{','.join(temperatures)}\n"
    
    # Add per-temperature voltage specifications
    temp_voltage_lines = []
    if temp_voltages:
        for temp in temperatures:
            # Look for temp_XX_voltages in the dict
            volt_key = f"temp_{temp}_voltages"
            if volt_key in temp_voltages:
                voltages = temp_voltages[volt_key]
                temp_voltage_lines.append(f"{volt_key}:{voltages}\n")
            else:
                # Fallback: if no voltage spec, use all 5 dual-supply combinations
                default_voltages = 'v1min_v2min,v1min_v2max,v1max_v2min,v1max_v2max,v1nom_v2nom'
                temp_voltage_lines.append(f"{volt_key}:{default_voltages}\n")
    
    # Insert temp_list and temp voltage lines after condition line
    for i, line in enumerate(lines):
        if line.startswith('condition:'):
            lines.insert(i + 1, temp_list_line)
            for temp_line in temp_voltage_lines:
                lines.insert(i + 2, temp_line)
            break
    
    # Write updated config
    with open(config_path, 'w') as f:
        f.writelines(lines)
    
    temp_str = ', '.join([f"{t}¬∞C" for t in temperatures])
    volt_summary = ''
    if temp_voltages:
        volt_counts = [len(temp_voltages.get(f"temp_{t}_voltages", '').split(',')) for t in temperatures]
        volt_summary = f", voltages={volt_counts}"
    
    print(f"  ‚úì Updated config.cfg: condition={condition_value}, temp_list={temp_str}{volt_summary}, CPU={nb_cores}, MEM={nb_memory}GB")
    
    # Generate custom table_corner_list.csv
    config_dir = os.path.join(work_dir, "configuration")
    os.makedirs(config_dir, exist_ok=True)
    
    corner_list_str = ' '.join(corners)
    
    # Always use typical extraction (no cross extraction in new UI)
    extraction_type = 'typical'
    
    csv_content = "type,extraction,corner list\n"
    csv_content += f"custom,{extraction_type},{corner_list_str}\n"
    
    csv_path = os.path.join(config_dir, "table_corner_list.csv")
    with open(csv_path, 'w') as f:
        f.write(csv_content)
    
    print(f"  ‚úì Created custom corner CSV: {corner_list_str}")
    
    # Copy read_corner.sh (same for all corner sets)
    source_corner_sh = "/nfs/site/disks/km6_io_37/users/chinseba/simulation/wkpup/i3c/1p1v/configuration/read_corner.sh"
    if os.path.exists(source_corner_sh):
        shutil.copy(source_corner_sh, os.path.join(config_dir, "read_corner.sh"))
        print(f"  ‚úì Copied read_corner.sh")
    
    return True


def run_generation_stage(work_dir: str) -> bool:
    """
    Run generation stage (gen_tb.pl creates testbenches)
    Requires Cheetah environment to be setup before webapp start
    
    Args:
        work_dir: Working directory path
        
    Returns:
        True if successful, False otherwise
    """
    print("üîß Running generation stage...")
    
    try:
        # Run generation (Cheetah env must be already set up)
        result = subprocess.run(
            ['bash', 'sim_pvt_local.sh', 'config.cfg', 'gen'],
            cwd=work_dir,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            universal_newlines=True,
            timeout=600  # 10 minute timeout
        )
        
        if result.returncode != 0:
            print(f"‚ùå Generation failed: {result.stderr}")
            return False
        
        print("  ‚úì Generation completed")
        return True
        
    except subprocess.TimeoutExpired:
        print("‚ùå Generation timed out")
        return False
    except Exception as e:
        print(f"‚ùå Generation error: {e}")
        return False


def run_submission_stage(work_dir: str) -> str:
    """
    Run submission stage (submit jobs to NetBatch)
    Must be run with Cheetah environment setup
    
    Args:
        work_dir: Working directory path
        
    Returns:
        Path to job_log.txt if successful, None otherwise
    """
    print("üöÄ Running submission stage...")
    
    try:
        # Run submission (Cheetah env is already active from webapp launcher)
        # Do NOT re-run cth_psetup - it will fail if already in Cheetah shell
        result = subprocess.run(
            ['bash', 'sim_pvt_local.sh', 'config.cfg', 'run'],
            cwd=work_dir,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            universal_newlines=True,
            timeout=1200  # 20 minute timeout
        )
        
        if result.returncode != 0:
            print(f"‚ùå Submission failed: {result.stderr}")
            return None
        
        job_log_path = os.path.join(work_dir, "job_log.txt")
        
        if os.path.exists(job_log_path):
            print("  ‚úì Submission completed")
            return job_log_path
        else:
            print("‚ùå job_log.txt not found after submission")
            return None
        
    except subprocess.TimeoutExpired:
        print("‚ùå Submission timed out")
        return None
    except Exception as e:
        print(f"‚ùå Submission error: {e}")
        return None


def run_extraction_stage(work_dir: str) -> bool:
    """
    Run extraction stage (local_extract.sh)
    
    Args:
        work_dir: Working directory path
        
    Returns:
        True if successful
    """
    print("üìä Running extraction stage...")
    
    try:
        result = subprocess.run(
            ['bash', 'sim_pvt_local.sh', 'config.cfg', 'ext'],
            cwd=work_dir,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            universal_newlines=True,
            timeout=600  # 10 minute timeout
        )
        
        if result.returncode != 0:
            print(f"‚ö†Ô∏è Extraction had warnings: {result.stderr}")
            # Don't fail - extraction might partially succeed
        
        print("  ‚úì Extraction completed")
        return True
        
    except subprocess.TimeoutExpired:
        print("‚ùå Extraction timed out")
        return False
    except Exception as e:
        print(f"‚ùå Extraction error: {e}")
        return False


def run_sorting_stage(work_dir: str) -> bool:
    """
    Run sorting stage (compile reports)
    
    Args:
        work_dir: Working directory path
        
    Returns:
        True if successful
    """
    print("üìã Running sorting stage...")
    
    try:
        result = subprocess.run(
            ['bash', 'sim_pvt_local.sh', 'config.cfg', 'srt'],
            cwd=work_dir,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            universal_newlines=True,
            timeout=300  # 5 minute timeout
        )
        
        # Check for creport.txt
        creport_path = os.path.join(work_dir, "report", "creport.txt")
        
        if not os.path.exists(creport_path):
            print(f"‚ùå creport.txt not created")
            return False
        
        print(f"  ‚úì Sorting completed, creport at: {creport_path}")
        return True
        
    except subprocess.TimeoutExpired:
        print("‚ùå Sorting timed out")
        return False
    except Exception as e:
        print(f"‚ùå Sorting error: {e}")
        return False


def run_backup_stage(work_dir: str) -> Optional[str]:
    """
    Run backup stage (create timestamped backup)
    
    Args:
        work_dir: Working directory path
        
    Returns:
        Path to backup directory if successful, None otherwise
    """
    print("üíæ Running backup stage...")
    
    try:
        result = subprocess.run(
            ['bash', 'sim_pvt_local.sh', 'config.cfg', 'bkp'],
            cwd=work_dir,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            universal_newlines=True,
            timeout=600  # 10 minute timeout
        )
        
        # Find backup directory (00bkp_YYYYMMDDHHMM) - created in work_dir itself
        backup_dirs = [d for d in os.listdir(work_dir) if d.startswith('00bkp_')]
        
        if not backup_dirs:
            print(f"‚ùå No backup directory created in {work_dir}")
            return None
        
        # Get most recent backup
        backup_dir = os.path.join(work_dir, sorted(backup_dirs)[-1])
        
        print(f"  ‚úì Backup completed at: {backup_dir}")
        return backup_dir
        
    except subprocess.TimeoutExpired:
        print("‚ùå Backup timed out")
        return None
    except Exception as e:
        print(f"‚ùå Backup error: {e}")
        return None


# Test function
if __name__ == "__main__":
    print("Testing simulation orchestration...")
    sim_id = generate_sim_id()
    print(f"Generated sim_id: {sim_id}")
    
    # Note: Don't actually create directories in test mode
    print("\n‚úÖ Module loaded successfully")
